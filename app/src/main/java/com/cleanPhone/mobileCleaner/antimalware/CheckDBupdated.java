package com.cleanPhone.mobileCleaner.antimalware;

import android.content.Context;
import android.os.AsyncTask;
import android.util.Log;

import com.cleanPhone.mobileCleaner.MobiClean;
import com.cleanPhone.mobileCleaner.R;
import com.cleanPhone.mobileCleaner.filestorage.DialogConfigs;
import com.cleanPhone.mobileCleaner.utility.GlobalData;
import com.cleanPhone.mobileCleaner.utility.SharedPrefUtil;
import com.cleanPhone.mobileCleaner.utility.Util;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.HttpURLConnection;
import java.net.URL;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

public class CheckDBupdated extends AsyncTask<String, String, Boolean> {
    private static final int RETRY_COUNT = 3;
    private static final String TAG = "UPDATE_SERVICE";
    private static final String ZIP_NAME = "db.zip";
    private Context context;
    private String pathFile;
    private String pathFolder;
    private HttpURLConnection urlConnection;

    public CheckDBupdated(Context context) {
        this.context = context;
        Util.appendLogmobicleanTest(TAG, "checking service started  ", "dblog.txt");
    }

    public static String calculateMD5(File file) {
        try {
            MessageDigest messageDigest = MessageDigest.getInstance("MD5");
            FileInputStream fileInputStream = new FileInputStream(file);
            byte[] bArr = new byte[8192];
            while (true) {
                try {
                    try {
                        int read = fileInputStream.read(bArr);
                        if (read <= 0) {
                            break;
                        }
                        messageDigest.update(bArr, 0, read);
                    } catch (Throwable th) {
                        try {
                            fileInputStream.close();
                        } catch (IOException unused) {
                        }
                        throw th;
                    }
                } catch (IOException e) {
                    throw new RuntimeException("Unable to process file for MD5", e);
                }
            }
            String replace = String.format("%32s", new BigInteger(1, messageDigest.digest()).toString(16)).replace(' ', '0');
            Log.i("TEST_VIRUS", "MD5 of file : " + file + "is ---::" + replace);
            try {
                fileInputStream.close();
            } catch (IOException unused2) {
            }
            return replace;
        } catch (FileNotFoundException | NoSuchAlgorithmException unused3) {
            return null;
        }
    }

    private boolean downloadDB() {
        String calculateMD5 = new String();
        Util.appendLogmobicleanTest(TAG, " downloading zip from " + MobiClean.getInstance().dbxmlData.getDownloadURL(), "dblog.txt");
        try {
            this.pathFolder = "/data/data/" + this.context.getPackageName() + "/databases/";
            StringBuilder sb = new StringBuilder();
            sb.append(this.pathFolder);
            sb.append(ZIP_NAME);
            this.pathFile = sb.toString();
            Util.appendLogmobicleanTest(TAG, " saving to path " + this.pathFile, "dblog.txt");
            File file = new File(this.pathFolder);
            if (!file.exists()) {
                file.mkdirs();
            }
            URL url = new URL(MobiClean.getInstance().dbxmlData.getDownloadURL());
            url.openConnection().connect();
            BufferedInputStream bufferedInputStream = new BufferedInputStream(url.openStream());
            FileOutputStream fileOutputStream = new FileOutputStream(this.pathFile);
            byte[] bArr = new byte[1024];
            while (true) {
                int read = bufferedInputStream.read(bArr);
                if (read == -1) {
                    break;
                }
                fileOutputStream.write(bArr, 0, read);
            }
            fileOutputStream.flush();
            fileOutputStream.close();
            bufferedInputStream.close();
            Util.appendLogmobicleanTest(TAG, "zip downloaded to " + this.pathFile, "dblog.txt");
            try {
                Util.appendLogmobicleanTest(TAG, "calculating hash ", "dblog.txt");
                calculateMD5 = calculateMD5(new File(this.pathFile));
                Util.appendLogmobicleanTest(TAG, "hash of downloaded zip file " + calculateMD5, "dblog.txt");
            } catch (Exception e) {
                e.printStackTrace();
            }
            if (calculateMD5.equalsIgnoreCase(MobiClean.getInstance().dbxmlData.getHash())) {
                Util.appendLogmobicleanTest(TAG, "both hash are same now unzip ", "dblog.txt");
                return unpackZip(this.pathFolder, "/db.zip");
            }
            Util.appendLogmobicleanTest(TAG, "both hash are not same ", "dblog.txt");
            return false;
        } catch (Exception e2) {
            Util.appendLogmobicleanTest(TAG, "Exception in downloading " + e2.getMessage(), "dblog.txt");
            Log.e("Error: ", e2.getMessage());
            return false;
        }
    }

    private void fetchUrl(String str) throws IOException {
        HttpURLConnection httpURLConnection;
        HttpURLConnection httpURLConnection2 = null;
        HttpURLConnection httpURLConnection3 = null;
        InputStream inputStream = null;
        this.urlConnection = null;
        int i = 0;
        while (i < 3) {
            i++;
            try {
                try {
                    Util.appendLogmobicleanTest(TAG, "hitting url  try count = " + i, "dblog.txt");
                    httpURLConnection3 = (HttpURLConnection) new URL(str).openConnection();
                    this.urlConnection = httpURLConnection3;
                } catch (Exception e) {
                    Util.appendLogmobicleanTest(TAG, e.getMessage() + " Exception in hitting url count = " + i, "dblog.txt");
                    Log.e("", e.toString());
                    if (inputStream != null) {
                        inputStream.close();
                    }
                    httpURLConnection = this.urlConnection;
                    if (httpURLConnection != null) {
                    }
                }
                if (httpURLConnection3.getResponseCode() == 200) {
                    inputStream = this.urlConnection.getInputStream();
                    new DataParser().parseXml(inputStream);
                    if (httpURLConnection2 != null) {
                        return;
                    }
                    return;
                }
                Util.appendLogmobicleanTest(TAG, "response not received  try count = " + i, "dblog.txt");
                if (inputStream != null) {
                    inputStream.close();
                }
                httpURLConnection = this.urlConnection;
                if (httpURLConnection != null) {
                    httpURLConnection.disconnect();
                }
            } finally {
                if (inputStream != null) {
                    inputStream.close();
                }
                httpURLConnection2 = this.urlConnection;
                if (httpURLConnection2 != null) {
                    httpURLConnection2.disconnect();
                }
            }
        }
    }

    private boolean unpackZip(String str, String str2) {
        try {
            ZipInputStream zipInputStream = new ZipInputStream(new BufferedInputStream(new FileInputStream(str + str2)));
            byte[] bArr = new byte[1024];
            while (true) {
                ZipEntry nextEntry = zipInputStream.getNextEntry();
                if (nextEntry == null) {
                    break;
                }
                String name = nextEntry.getName();
                if (nextEntry.isDirectory()) {
                    new File(str + DialogConfigs.DIRECTORY_SEPERATOR + name).mkdirs();
                } else {
                    FileOutputStream fileOutputStream = new FileOutputStream(str + name);
                    while (true) {
                        int read = zipInputStream.read(bArr);
                        if (read == -1) {
                            break;
                        }
                        fileOutputStream.write(bArr, 0, read);
                    }
                    fileOutputStream.close();
                    zipInputStream.closeEntry();
                }
            }
            zipInputStream.close();
            Util.appendLogmobicleanTest(TAG, "unzipping successful ", "dblog.txt");
            File file = new File(str + str2);
            file.delete();
            Util.appendLogmobicleanTest(TAG, "Deleting file " + file.getPath(), "dblog.txt");
            Util.appendLogmobicleanTest(TAG, "Deleting file " + file.getAbsolutePath(), "dblog.txt");
            StringBuilder sb = new StringBuilder();
            sb.append("is file deleted ");
            sb.append(!file.exists());
            Util.appendLogmobicleanTest(TAG, sb.toString(), "dblog.txt");
            return true;
        } catch (IOException e) {
            Util.appendLogmobicleanTest(TAG, "exception in unzipping " + e.getMessage(), "dblog.txt");
            e.printStackTrace();
            return false;
        }
    }

    @Override
    public Boolean doInBackground(String... strArr) {
        int i = new SharedPrefUtil(this.context).getInt(SharedPrefUtil.CURRENTDB);
        publishProgress(this.context.getString(R.string.mbc_update_progress));
        try {
            fetchUrl(GlobalData.DB_UPDATE_URL);
        } catch (IOException e) {
            Util.appendLogmobicleanTest(TAG, e.getMessage() + " Exception in hitting url  ", "dblog.txt");
            e.printStackTrace();
        }
        if (MobiClean.getInstance().dbxmlData == null) {
            return Boolean.TRUE;
        }
        if (MobiClean.getInstance().dbxmlData.getDownloadURL() == null) {
            return Boolean.TRUE;
        }
        int parseInt = Integer.parseInt(MobiClean.getInstance().dbxmlData.getVersion());
        Util.appendLogmobicleanTest(TAG, " data received after hitting url ", "dblog.txt");
        Util.appendLogmobicleanTest(TAG, " Version =" + parseInt, "dblog.txt");
        Util.appendLogmobicleanTest(TAG, " URL =" + MobiClean.getInstance().dbxmlData.getDownloadURL(), "dblog.txt");
        Util.appendLogmobicleanTest(TAG, " Hash =" + MobiClean.getInstance().dbxmlData.getHash(), "dblog.txt");
        Util.appendLogmobicleanTest(TAG, " size =" + MobiClean.getInstance().dbxmlData.getSize(), "dblog.txt");
        Util.appendLogmobicleanTest(TAG, " Saved DB Version " + i, "dblog.txt");
        if (i < parseInt) {
            Util.appendLogmobicleanTest(TAG, " saved db version < DB from server", "dblog.txt");
            publishProgress(this.context.getString(R.string.mbc_update_progress));
            if (downloadDB()) {
                new SharedPrefUtil(this.context).saveInt(SharedPrefUtil.CURRENTDB, Integer.parseInt(MobiClean.getInstance().dbxmlData.getVersion()));
                String str = new SharedPrefUtil(this.context).getInt(SharedPrefUtil.CURRENTDB) + GlobalData.DB_NAME;
                publishProgress(this.context.getString(R.string.mbc_update_complete));
            } else {
                publishProgress(this.context.getString(R.string.mbc_update_error));
                return Boolean.FALSE;
            }
        } else {
            Util.appendLogmobicleanTest(TAG, " saved db version > DB from server", "dblog.txt");
        }
        return Boolean.valueOf(i < parseInt);
    }
}
